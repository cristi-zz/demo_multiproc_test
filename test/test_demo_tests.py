import logging
import time
import pytest
import multiprocessing as mp

import misc
import fancyprint


# ====================================  SOME NICE RUNS ==========================

def test_nice_parameters():
    fancyprint.worker_function(4, "a:")


def test_without_mp_that_raises_exception():
    """
    A lengthly message should raise an exception. This will be the "template" used when we want to trigger an exception.
    
    With <<with pytest.raises(Exception):>> command we tell this, to the pytest.
    """
    with pytest.raises(Exception):
        fancyprint.worker_function(40, "large stem")


def test_with_mp_and_nice_params():
    """
    Code is ran through a different process. Text is observed maybe at the output, but that's it.

    Everything is nice and jolly, but is it now?
    """
    kwargs = {"no_messages":4, "message_stem":"a:"}
    main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
    main_proc.start()
    main_proc.join(1)


@pytest.mark.xfail(reason="Exceptions don't propagate outside their process")
def test_with_mp_and_not_nice_params():
    """
    This function WILL fail because there is no way an exception will propagate outside the process env.

    The <<mark.xfail>> will tell the pytest to not count this as a failed test. Because we show a failed test here.
    Well, a test that should fail, but it does not. Remember  <<test_without_mp_that_raises_exception>> function above?

    Note: A keen reader might notice the exception in plain text, in the IDE's output! This means that it was raised but
    it was silently ignored by the time the control propagated back to this test function.
    """
    with pytest.raises(Exception):
        kwargs = {"no_messages":40, "message_stem":"large stem"}
        main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
        main_proc.start()
        main_proc.join(1)


# ====================================  LOGGING =============================
"""
One way to "extract" info from multiprocessing is through the logging system. But things are not that simple.

"""


@pytest.mark.xfail(reason="caplog does not work over processes")
def test_with_mp_and_default_logging_fixture(caplog):
    """
    Demonstration that caplog DOES NOT catch the messages inside another process.

    :param caplog:
    :return:
    """
    caplog.set_level(logging.DEBUG, logger="queued")

    kwargs = {"no_messages": 40, "message_stem": "large stem"}
    main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
    main_proc.start()
    main_proc.join(1)

    assert len(caplog.records) > 0, "There were no messages recorded!"

    any_error = False
    for r in caplog.records:
        if r.levelno > logging.INFO:
            any_error = True
    assert any_error, "There must be at least one ERROR/EXCEPTION in the logs"


def test_with_mp_and_custom_logging_fixture(memlogger):
    """
    The custom made memlogger, that correctly hooks into the multiprocessing env, captures the exception!

    Note that the memlogger is a custom fixture, generated by the pytest, upon request, from conftest.py

    :param memlogger:
    :return:
    """
    kwargs = {"no_messages": 40, "message_stem": "large stem"}
    main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
    main_proc.start()
    main_proc.join(1)

    assert len(memlogger.buffer) > 0, "There were no messages recorded!"

    any_error = False
    for r in memlogger.buffer:
        if r.levelno > logging.INFO:
            any_error = True
    assert any_error, "There must be at least one ERROR/EXCEPTION in the logs"

    with pytest.raises(Exception):
        misc.assert_no_errors_in_logs(memlogger.buffer)  # Basically the code above. We will use this instruction from now on.


"""
Some tests to assert that there are no interference between multiple test runs. The memlogger fixture is fresh, each time.
"""

def test_memlogger_is_empty(memlogger):
    assert len(memlogger.buffer) == 0
    logging.debug("Some message")
    time.sleep(0.1) # allow the message to go through the hops
    assert len(memlogger.buffer) == 1


def test_memlogger_is_always_empty(memlogger):
    assert len(memlogger.buffer) == 0
    logging.debug("Some message")
    time.sleep(0.1) # allow the message to go through the hops
    assert len(memlogger.buffer) == 1

# ====================================  MOCKING =============================

"""
Testing is nice, excellent when it can be performed in isolation. However, most of the times, in complex test scenarios
we must isolate a bit further the tested code. In python, mocks are fairly easy to work with. And powerful. 

You guessed it, there are some caveats when multiprocessing. No worries, there are workarounds!

By default, mocking in multiprocessing is a one way street. We can inject (incl behavior) but we can't measure what
happened inside another process. Ok, not without some magic. 

"""

def test_mock_print_func(mocker):
    """
    Basic mocker demonstration.

    mocker is a default pytest fixture. Note how we observe the numbers of calls on <<display_function>>
    """
    display_mock = mocker.patch("fancyprint.display_function")  # yeah, I know, read the docs, why
    no_msgs = 3
    fancyprint.worker_function(no_msgs, "A")
    display_mock.assert_called()
    assert display_mock.call_count == no_msgs


def test_mock_print_large_messages_truncated(mocker):
    display_mock = mocker.patch("fancyprint.display_function")
    no_msgs = 10
    with pytest.raises(Exception):
        fancyprint.worker_function(no_msgs, "A")
    display_mock.assert_called()
    assert display_mock.call_count < no_msgs, "The number of shown messages should be smaller"

@pytest.mark.xfail(reason="caplog does not work over processes")
def test_mock_print_from_mp(mocker, memlogger):
    """
    There is no way to get info about a mocker from inside a process. Note how the assert code in the end of the
    function, worked when it was ran in current process.

    """
    display_mock = mocker.patch("fancyprint.display_function")
    no_msgs = 3
    kwargs = {"no_messages":no_msgs, "message_stem":"A:"}
    main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
    main_proc.start()
    main_proc.join(1)
    misc.assert_no_errors_in_logs(memlogger.buffer)

    # There is no info propagated from inside the process to outside. Note how
    display_mock.assert_called()
    assert display_mock.call_count == no_msgs


def test_mock_print_large_messages_with_mock(mocker):
    """
    Yet another demo of mocking powers. We can enlarge the maximum message len by mocking the max_msg_length() function

    We will use this "demo" below. Note how we inject a mock, changing the behavior of the code.

    """
    display_mock = mocker.patch("fancyprint.display_function")
    msg_length_mock = mocker.patch("fancyprint.max_msg_length")
    msg_length_mock.return_value = 1000
    no_msgs = 100
    fancyprint.worker_function(no_msgs, "A long message")
    display_mock.assert_called()
    assert display_mock.call_count == no_msgs, "All messages should have been displayed"


def test_mock_print_large_messages_with_mock_from_mp(mocker, memlogger):
    """
    We can "inject" mocks with different behavior in another process, before it is started. Note the example above.

    """
    display_mock = mocker.patch("fancyprint.display_function")
    msg_length_mock = mocker.patch("fancyprint.max_msg_length")
    msg_length_mock.return_value = 1000
    no_msgs = 100
    kwargs = {"no_messages":no_msgs, "message_stem":"A:"}
    main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
    main_proc.start()
    main_proc.join(1)
    misc.assert_no_errors_in_logs(memlogger.buffer)  # This is one way in which we can observe exceptions. At least if they are logged.


# ====================================  MESSAGE RETRIEVING =============================
"""
We can inject test objects through mocking and they will act as expected inside another process. What happens with 
the other useful application of the mocks? Recording calls!

Well, we exploit the communication prototypes that multiprocessing has to offer. In Remote_Call_Recorder we have a
skeleton implementation of a mocker object. We generate objects of this type (Remote_Call_Recorder) then call them with 
whatever parameters.
We can retrieve these calls later, by  get_call_list(). This will return the list of calls with timestamp.

"""

def test_listen_to_calls_no_mp(mocker):
    """
    This is a demonstration of the Remote_Call_Recorder

    Note that with the exception of timestamp, there is no practical difference between this and an object
    generated by mocking.

    :param mocker:
    :return:
    """
    call_listener = misc.Remote_Call_Recorder()
    mocker.patch("fancyprint.display_function", call_listener)

    fancyprint.worker_function(3, 'A')

    calls = call_listener.get_call_list()
    timestamps, args_list, kwargs_list = zip(*calls)
    assert len(timestamps) == 3
    assert len(args_list) == 3
    assert len(kwargs_list) == 3
    assert len(args_list[0]) > 0


def test_register_a_call_listener_to_manager(mocker, memlogger):
    """
    We will inject the Remote_Call_Recorder object trhough the SyncManager and observe what is happening inside
    another process.

    Note how we can monitor how many times the function was called, their parameters, etc while passing through
    the isolation offered by a different process.
    """
    misc.TestCustomManagerClass.register('call_display_func', misc.Remote_Call_Recorder, exposed=misc.Remote_Call_Recorder.get_fn_list_to_register())
    test_manager = misc.TestCustomManagerClass()
    test_manager.start()
    call_display_func = test_manager.call_display_func()

    mocker.patch("fancyprint.display_function", call_display_func)

    no_msgs = 3
    kwargs = {"no_messages":no_msgs, "message_stem":"A:"}
    main_proc = mp.Process(target=fancyprint.worker_function, kwargs=kwargs)
    main_proc.start()
    main_proc.join(1)
    misc.assert_no_errors_in_logs(memlogger.buffer)

    calls = call_display_func.get_call_list()
    timestamps, args_list, kwargs_list = zip(*calls)
    assert len(args_list) == 3
    assert len(kwargs_list) == 3
    assert len(args_list[0]) > 0

    test_manager.shutdown()
    test_manager.join(1)

